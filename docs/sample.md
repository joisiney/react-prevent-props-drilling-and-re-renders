## Desvendando o Funcionamento!

Se voc√™ j√° est√° familiarizado DDD (domain driven design), ent√£o est√° no seu territ√≥rio! Este processo √© simples e emocionante de trabalhar. Aqui est√° como voc√™ pode come√ßar:

Primeiro, criamos uma aba de perfil. Olhe s√≥ para essa `Entity`:
```typescript
type UserEntity = {
    id: number;
    name: string;
    avatar?: string;
};
```

Agora, vamos dar vida a um `Model`. Este √© o cora√ß√£o do nosso sistema, respons√°vel por persistir e traduzir os dados para o front-end:

```typescript
export class UserModel {
    constructor(private readonly fields:UserEntity) {
    }
    get id() {
        return this.fields.id;
    }
    get nameUpper() {
        return this.fields.name.toUpperCase();
    }
    get nameLower() {
        return this.fields.name.toLowerCase();
    }
    toJSON() {
        return this.fields;
    }
}
```

Na `entity`, temos um conjunto de propriedades (fiel a API REST), mas no `Model`, escolhemos apenas alguns `getters`. Simplificando para manter a efici√™ncia e a clareza (Keep It Simple, Stupid).

Agora, aqui vem a parte emocionante! Temos o `repository`, que guarda e atualiza os nossos `model`. Mas lembre-se, nunca modificamos um `model`. Sempre recriamos. Veja como:
```typescript
class UserInMemoryRepository extends ObserverHelper<UserModel> {
    update(newUser:Partial<UserEntity>){
        this.data = new UserModel({...this.data.toJSON(), ...newUser});
        this.emitter(['user']);
    }
}
```

Agora, voc√™ pode estar se perguntando, como isso se encaixa no React? Ah, √© a melhor parte!

Criamos um gancho (hook) e disponibilizamos atrav√©s de React hooks, onde podemos acessar atualiza√ß√µes usando observadores:

```typescript
const userInMemoryRepository = new UserInMemoryRepository(new UserModel({
    id: 0,
    name: 'Joisiney'
}));

const useUserInMemoryObserver = createHookObserverHelper<UserModel, UserInMemoryRepository>(
    userInMemoryRepository
);
```
Com esse gancho pronto para uso, podemos simplesmente incorpor√°-lo em qualquer componente:

```typescript
export const ExampleOne:FC = () =>{
    const data = useUserInMemoryObserver({
        observable:['user']
    });
    return <div>
        <h1>{data?.nameUpper}</h1>
        <button onClick={()=>{
            userInMemoryRepository.update({
                name:'leandro'
            });
        }}>Atualizar nome</button>
    </div>;
};
```
E o melhor de tudo, podemos fazer isso globalmente! Veja o `ExampleUsage`:

```typescript
export const ExampleTwo:FC = () =>{
    const data = useUserInMemoryObserver({
        observable:['user']
    });
    return <div>
        <h1>{data?.nameUpper}</h1>
        <button onClick={()=>{
            userInMemoryRepository.update({
                name:'SILVA'
            });
        }}>Atualizar nome</button>
    </div>;
};
```
O mesmo que ocorre com o componente `ExampleOne` ocorre com o componente `ExampleTwo` s√≥ que desta vez tudo em minusculo.

```typescript
export const ExampleUsage:FC = () =>{
    const counterRef = useRef(0);
    return <>
        <p>Counter re-render ({counterRef.current++})</p>
        <ExampleOne/>
        <ExampleTwo/>
    </>;
};
```

Neste exemplo, os componentes `ExampleOne` e `ExampleTwo` est√£o sincronizados. Incr√≠vel, n√£o √©?

Isso significa que, mesmo que voc√™ altere um componente, o outro reage instantaneamente.

E o `ExampleUsage`? Ele n√£o precisa ser renderizado novamente! Isso acontece porque o `repository` √© global, mantendo todos os dados intactos enquanto navegamos pelo projeto. Isso tamb√©m implica que `counterRef.current++` nunca ser√° acionado, pelo menos n√£o por este motivo üöÄ.